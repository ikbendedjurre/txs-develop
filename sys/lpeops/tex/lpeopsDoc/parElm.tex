\chapter{parelm}

\section{Introduction}

An LPE may have parameters that do not affect the behavior of that process in any way.
These parameters are said to be \emph{inert}.
Removing inert parameters from an LPE reduces the size of state vectors and the state space of that LPE, which both benefits performance.

\section{Implementation}

The algorithm consists of the following steps \cite{groote2001computer}:

\begin{enumerate}

\item Mark all parameters of the LPE as `inert'.

\item Consider the guards of all summands of the LPE.
Unmark all LPE parameters that occur in the guard of a summand.

\item Let $P$ be the set of all LPE parameters that are marked as `inert', and consider all expressions $v_s(p)$ that define the value of an LPE parameter $p$ after application of a summand $s$.
For each such expression, if $p$ is \emph{not} marked as `inert', unmark all LPE parameters that occur in $v_s(p)$.

\item Repeat the previous step until the fixpoint of $P$ is reached.
Then remove all LPE parameters that are still marked as `inert' from the LPE, substituting references to those parameters by their initial values.

\end{enumerate}

\clearpage
\section{Example TOCHECK}

Consider the following LPE:

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, y, z :: Int)
  = A ? i [[x==0]] >-> example[A, B](i, y, z)
  + A ? i [[x==1]] >-> example[A, B](0, i, z)
  + B [[x==2]] >-> example[A, B](0, y, z)
  + B >-> example[A, B](z, y, x)
  ;

//Initialization:
example[A, B](0, 0, 0);
\end{lstlisting}

First, $x$ is unmarked, because it occurs in the guards of the first three summands.

In the fourth summand, $z$ is used in the expression of which the value is assigned to $x$.
Therefore $z$ must also be unmarked.

$y$ remains marked: it does not occur in a guard, nor is it used in the assignment to a process parameter other than itself.
Removing $y$ gives

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, z :: Int)
  = A ? i [[x==0]] >-> example[A, B](i, z)
  + A ? i [[x==1]] >-> example[A, B](0, z)
  + B [[x==2]] >-> example[A, B](0, z)
  + B >-> example[A, B](z, x)
  ;

//Initialization:
example[A, B](0, 0);
\end{lstlisting}



