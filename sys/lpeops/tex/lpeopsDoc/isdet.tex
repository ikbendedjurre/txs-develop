\chapter{isdet}

\section{Introduction}

The \texttt{isdet} command checks whether the specified LPE is deterministic.
The command may yield false negatives.

\section{Background theory}

\subsection{Summand non-determinism}

Consider two summands, $s_1$ and $s_2$, defined as
\begin{align*}
s_i = C_i \; \texttt{?} \; x_i(1) \; \cdots{} \; \texttt{?} \; x_i(m_i) \; [[g_i]] \; \texttt{>->} \; P(v_i(p_1), \cdots{}, v_i(p_k))
\end{align*}

where

\begin{itemize}
\item $C_i$ is the name of the channel over which summand $s_i$ communicates;
\item $m_i \geq 0$ is the number of variables that summand $s_i$ uses to communicate over channel $C_i$;
\item $x_i(j)$ is the variable that summand $s_i$ uses to communicate the $j$th value of channel $C_i$;
\item $g_i$ is the guard of summand $s_i$ (the only free variables in this expression must be LPE parameters or communication variables of summand $s_i$);
\item $P$ is the LPE to which summand $s_i$ belongs;
\item $p_1, \cdots{}, p_k$ are the parameters of the LPE, of which there are $k \geq 0$;
\item $v_i(p)$ is an expression that defines the new value of LPE parameter $p$ after the application of summand $s_i$ (the only free variables in this expression must be LPE parameters or communication variables of summand $s_i$).
\end{itemize}

Summand $s_1$ is said to be \emph{deterministic with} $s_2$ if one of these conditions holds:

\begin{itemize}
\item $s_1$ and $s_2$ are the same summand; that is, $s_1 = s_2$.

\item $s_1$ and $s_2$ communicate over different channels:
\begin{align*}
C_1 \neq C_2 \land (C_1 \in \{\istep{}, \cistep{}\} \not\leftrightarrow C_2 \in \{\istep{}, \cistep{}\})
\end{align*}

\item $s_1$ and $s_2$ communicate with different numbers of communication variables; that is, $m_1 \neq m_2$.

\item $s_1$ and $s_2$ are never simultaneously enabled, or $s_1$ and $s_2$ always lead to the same next state.
In order to determine this, check if
\begin{align*}
g_1[V_2] \land g_2 \rightarrow \bigwedge\limits_{j=1}^{k} v_1(p_j)[V_2] = v_2(p_j)
\end{align*}

is a tautology, where $V_2$ is defined as
\begin{align*}
V_{2} &= [x_1(j) \rightarrow x_2(j) \;|\; 1 \leq j \leq \text{min}(m_1, m_2)]
\end{align*}
\end{itemize}

Note that this approach is \emph{not} guaranteed to correctly recognize that two summands are deterministic (false negatives are tolerated)!

\section{Implementation}

The algorithm invoked by the \texttt{isdet} command checks for all pairs of different summands whether the first summand is deterministic with the second summand (see the previous section).
The algorithm yields \textbf{true} if and only if this is the case for all summand pairs.

%\begin{lstlisting}
%//Process definition:
%PROCDEF counterexample[A :: Int](x :: Int)
  %= A ? i [[x mod 2 == 0 && i mod 2 == 0]] >-> example[A](i + 1)
  %+ A ? i [[x == 11 && i == 11]] >-> example[A](11)
  %+ A ? i [[x == 13 && i == 13]] >-> example[A](13)
  %+ A ? i [[x == 17 && i == 17]] >-> example[A](17)
  %;
%
%//Initialization:
%example[A, B](0, 0);
%\end{lstlisting}

\section{Example TODO}

Consider the following LPE:

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, y :: Int)
  = A ? i [[x==0 /\ i>=0 /\ i<=5]] >-> example[A, B](1, 0)
  + A ? i [[y==0 /\ i>=5 /\ i<=9]] >-> example[A, B](0, 1)
  ;

//Initialization:
example[A, B](0, 1);
\end{lstlisting}

Consider the two summands, calling the first $s_1$ and the second $s_2$.

The first three conditions for detecting determinism are false.

For the fourth condition, the antecedent is
\begin{align*}
g_1[V_2] \land g_2 &\Leftrightarrow (\texttt{x} = 0 \land \texttt{i} \geq 0 \land \texttt{i} \leq 5)[\texttt{i} \rightarrow \texttt{i}] \land (\texttt{y} = 0 \land \texttt{i} \geq 5 \land \texttt{i} \leq 9) \\
&\Leftrightarrow \texttt{x} = 0 \land \texttt{y} = 0 \land \texttt{i} = 5
\end{align*}

Given the antecedent, the conclusion must hold.
This is not the case:
\begin{align*}
v_1(\texttt{x})[V_2] = 1[\texttt{i} \rightarrow \texttt{i}] = 1 \neq 0 = v_2(\texttt{x}) \\
v_1(\texttt{y})[V_2] = 0[\texttt{i} \rightarrow \texttt{i}] = 0 \neq 1 = v_2(\texttt{y}) \\
\end{align*}

$s_1$ is therefore \emph{not} deterministic with $s_2$.

Changing the LPE to

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, y :: Int)
  = A ? i [[x==0 /\ i>=0 /\ i<=4]] >-> example[A, B](1, 0)
  + A ? i [[y==0 /\ i>=5 /\ i<=9]] >-> example[A, B](0, 1)
  ;

//Initialization:
example[A, B](0, 1);
\end{lstlisting}

will result in an antecedent that is false; consequently, $s_1$ is deterministic with $s_2$.

