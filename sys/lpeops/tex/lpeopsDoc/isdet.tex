\chapter{isdet}

\section{Introduction}

The \texttt{isdet} command checks whether the specified LPE is deterministic.
The command may yield false positives.

\section{Background theory}

\subsection{Summand non-determinism}

Consider two summands, $s_1$ and $s_2$, defined as

\begin{align*}
s_i &= C_i(1) \;|\; \cdots{} \;|\; C_i(n_i) \; [[g_i]] \text{ \texttt{>->} } P(p_1 = f_i(p_1), \cdots{}, p_m = f_i(p_m)) \\
C_i(x) &= c_i(x) \text{ \texttt{?} } v_i(x,1) \cdots{} \text{ \texttt{?} } v_i(x,k_i(x))
\end{align*}

where

\begin{itemize}
\item $C_i(1) \;|\; \cdots{} \;|\; C_i(n_i)$ are the channel communications used in summand $s_i$;
\item $n_i \geq 0$ is the number of channels over which summand $s_i$ communicates;
\item $g_i$ is the guard of summand $s_i$ (the only free variables in this expression must be LPE parameters or communication variables of summand $s_i$);
\item $P$ is the LPE to which summand $s_i$ belongs;
\item $p_1, \cdots{}, p_m$ are the parameters of the LPE, of which there are $m \geq 0$;
\item $f_i(p)$ is an expression that defines the new value of LPE parameter $p$ after the application of summand $s_i$ (the only free variables in this expression must be LPE parameters or communication variables of summand $s_i$);
\item $c_i(x)$ is the name of the $x$th channel over which summand $s_i$ communicates;
\item $v_i(x,y)$ is the variable that summand $s_i$ uses to communicate the $y$th value of the $x$th channel;
\item $k_i(x)$ is the number of variables that summand $s_i$ uses to communicate over the $x$th channel.
\end{itemize}

Summand $s_1$ is said to be \emph{non-deterministic with} $s_2$ if these two conditions hold:

\begin{itemize}
\item $s_1$ and $s_2$ must communicate over exactly the same channels with exactly as many channel variables; that is,
\begin{align*}
n_1 = n_2 \land \forall x \in [1, \cdots{}, n_1] \;.\; c_1(x) = c_2(x) \land k_1(x) = k_2(x)
\end{align*}

\item Given the previous condition, define
\begin{align*}
n &= n_1 = n_2 \\
k(x) &= k_1(x) = k_2(x) \text{ for all } x \in [1, \cdots{}, n]
\end{align*}

and define, in particular, the mapping
\begin{align*}
V = [v_2(x,y) \rightarrow v_1(x,y) \;|\; x \in [1, \cdots{}, n], y \in [1, \cdots{}, k(x)]]
\end{align*}

Consider the expression $g_1 \land g_2[V]$.
If a solution for this expression definitely exists or if a solution is unknown, the condition holds.
If there is definitely \emph{no} solution for the expression, this condition fails.
\end{itemize}

\section{Implementation}

The algorithm invoked by the \texttt{isdet} command checks for all pairs of different summands whether the first summand is non-deterministic with the second summand (see the previous section).
If a summand pair is found for which this is the case, the algorithm yields \textbf{false}.
Otherwise, the algorithm yields \textbf{true}.


%\begin{lstlisting}
%//Process definition:
%PROCDEF counterexample[A :: Int](x :: Int)
  %= A ? i [[x mod 2 == 0 && i mod 2 == 0]] >-> example[A](i + 1)
  %+ A ? i [[x == 11 && i == 11]] >-> example[A](11)
  %+ A ? i [[x == 13 && i == 13]] >-> example[A](13)
  %+ A ? i [[x == 17 && i == 17]] >-> example[A](17)
  %;
%
%//Initialization:
%example[A, B](0, 0);
%\end{lstlisting}

\section{Example TODO}

Consider the following LPE:

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, y :: Int)
  = A ? i [[x==0]] >-> example[A, B](1, i)
  + A ? i [[x==1 && i==y]] >-> example[A, B](2, y)
  + B [[x==2]] >-> example[A, B](3, y)
  + B [[x==3]] >-> example[A, B](0, y)
  ;

//Initialization:
example[A, B](0, 0);
\end{lstlisting}

Finding the successors of each summand is easy: each summand has exactly one successor, namely the next one, except in case of the fourth summand, where the first summand is the successor.

It is also obvious that $x$ will always be in $R_s$ for each summand $s$, because each summand uses $x$ in its guard.

Process parameter $y$ will always be in $R_{s_1}$, where $s_1$ is the first summand, because $y$ is used in the guard of $s_1$'s successor (the second summand).
After a few iterations, however, $y$ is removed from $R_{s_2}$ to $R_{s_4}$.
This means that $y$ is assigned a default value in the corresponding summands.
Depending on the mood of the SMT solver, this could give

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, y :: Int)
  = A ? i [[x==0]] >-> example[A, B](1, i)
  + A ? i [[x==1 && i==y]] >-> example[A, B](2, 0)
  + B [[x==2]] >-> example[A, B](3, 0)
  + B [[x==3]] >-> example[A, B](0, 0)
  ;

//Initialization:
example[A, B](0, 0);
\end{lstlisting}




