\chapter{parreset}

\section{Introduction}

An LPE may have parameters of which the values are not used anymore after a particular state.
If such parameters can have different values after that state, they continue to add states to the state space for each of those values -- \emph{without} adding any new behavior!

The \texttt{parreset} command tries to determine whether the value of a parameter is used by an LPE after a particular summand.
If this is the case, the parameter is said to be \emph{relevant} for that summand; otherwise, the summand can `reset' the parameter, meaning that it can be assigned a default value.

To determine the relevance of parameters, \texttt{parreset} analyzes the reachability of summands in a generalized, symbolic manner.
\texttt{datareset}, serving a similar purpose, does a control-flow analysis.

\section{Formal background}

\subsection{Possible successors}

Consider all possible pairs of summands of the LPE (including symmetric pairs).
Of a given summand pair $(s, t)$, let $t$ be a \emph{possible successor} of $s$ if the following equation is satisfiable:
\begin{align*}
c_s \land {c_t}[p \rightarrow q(p) \;|\; p \in P][q(p) \rightarrow v_s(p) \;|\; p \in P]
\end{align*}

where

\begin{itemize}
\item $c_s$ and $c_t$ are the guards of summands $s$ and $t$, respectively;
\item $P$ is the set of all LPE parameters;
\item $q(p)$ is a bijective function that relates LPE parameter $p$ to a fresh variable;
\item $v_s(p)$ is the expression that defines the new value of LPE parameter $p$ after the application of summand $s$.
\end{itemize}

The fresh variables of the bijective function $q(p)$ are necessary to distinguish LPE parameters before and after the application of summand $s$ (if $p$ is the LPE parameter before, then $q(p)$ is the LPE parameter after).

\section{Implementation}

The algorithm is a generalization of an existing algorithm \cite{van2009state}.
It consists of two phases.

During the first phase (the preparation phase), we determine all successors of each summand of the LPE using the equation from the previous section.

The second phase (the iteration phase) follows these steps:

\begin{enumerate}

\item For each summand $s$ of the LPE, create a set $R_s$ that contains all parameters of the LPE.
This means that, initially, we assume that all parameters of the LPE are used by one or more of the successors of $s$; that is, \emph{relevant} to $s$.

\item For each summand $s$ of the LPE, set the value of $R_s$ to $\bigcup\limits_{t \in S_s}^{} r(t)$ where $S_s$ is the set of all successors of $s$ (as determined during the preparation phase) and where $r$ is the function
\begin{align*}
r(t) = \left( \text{vars}(c_t) \cup \bigcup\limits_{x \in R_t}^{} \text{vars}(v_t(x)) \right) \setminus C_t
\end{align*}

where

\begin{itemize}
\item $\text{vars}(c_t)$ gives the free variables in $c_t$, the guard of summand $t$;
\item $v_t(p)$ is the expression that defines the value of LPE parameter $p$ after the application of summand $t$;
\item $\text{vars}(v_t)$ gives the free variables in $v_t$;
\item $C_t$ is the set of the communication variables used by summand $t$.
\end{itemize}

\item Repeat the previous step until the fixpoint of $R_s$ is reached for each summand $s$ of the LPE.

\item For each summand $s$ and for all $p \in P \setminus R_s$, change the expression $v_s(p)$ (which defines the value of LPE parameter $p$ after the application of $s$) to $v_I(p)$, the value of $p$ in this initial state of the LPE.

\end{enumerate}

\section{Example TOCHECK}

Consider the following LPE:

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, y :: Int)
  = A ? i [[x==0]] >-> example[A, B](1, i)
  + A ? i [[x==1 && i==y]] >-> example[A, B](2, y)
  + B [[x==2]] >-> example[A, B](3, y)
  + B [[x==3]] >-> example[A, B](0, y)
  ;

//Initialization:
example[A, B](0, 0);
\end{lstlisting}

Finding the successors of each summand is easy: each summand has exactly one successor, namely the next one, except in case of the fourth summand, where the first summand is the successor.

It is also obvious that $x$ will always be in $R_s$ for each summand $s$, because each summand uses $x$ in its guard.

Process parameter $y$ will always be in $R_{s_1}$, where $s_1$ is the first summand, because $y$ is used in the guard of $s_1$'s successor (the second summand).
After a few iterations, however, $y$ is removed from $R_{s_2}$ to $R_{s_4}$.
This means that $y$ is assigned a default value in the corresponding summands.
Depending on the mood of the SMT solver, this could give

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, y :: Int)
  = A ? i [[x==0]] >-> example[A, B](1, i)
  + A ? i [[x==1 && i==y]] >-> example[A, B](2, 0)
  + B [[x==2]] >-> example[A, B](3, 0)
  + B [[x==3]] >-> example[A, B](0, 0)
  ;

//Initialization:
example[A, B](0, 0);
\end{lstlisting}




