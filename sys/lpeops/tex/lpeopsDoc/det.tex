\chapter{det}

\section{Introduction}

Non-determinism in an LPE can have a strong impact on the performance of exploring its state space.
Preferably, an LPE should therefore be completely deterministic.
Unfortunately, there are no determinization methods known for symbolic models such as LPEs.

The \texttt{det} command described in this section is only a naive attempt at LPE determinization: it looks for two summands that are non-deterministic (see \ref{isdet}), and then rewrites the LPE so that these summands have become deterministic.
This may mean that the entire LPE has become deterministic, but more typically the non-determinism will have moved to a different part of the LPE.

The \texttt{det} command is intended to be repeated in the hope that non-determinism eventually disappears from the LPE.
It is definitely possible that this may never happen!
It is also likely that the LPE will grow very large; it is therefore advised to symbolically reduce the LPE using other LPE operations after each application of \texttt{det}.

\section{Algorithm}

Let the input LPE model be $M$ and the underlying LPE be $P$, and let two summands of $P$, $s_\alpha$ and $s_\beta$, be non-deterministic (see \ref{isdet}).
Elements of $s_\alpha$ and $s_\beta$ are referenced conform \ref{summandelements}.
Define
\begin{align*}
C_{\alpha,\beta} &= C_\alpha = C_\beta \\
m_{\alpha,\beta} &= m_\alpha = m_\beta \\
X_\alpha &= [ x_\beta(j) \rightarrow x_\alpha(j) \;|\; 1 \leq j \leq m_{\alpha,\beta} ] \\
X_\beta &= [ x_\alpha(j) \rightarrow x_\beta(j) \;|\; 1 \leq j \leq m_{\alpha,\beta} ]
\end{align*}

and let $y(j)$ be a bijective function that yields fresh variables for $1 \leq j \leq m_{\alpha,\beta}$.

The \texttt{det} algorithm follows these steps:

\begin{enumerate}
\item Create a new LPE $P'$ with the same parameters as $P$, but without any summands.
Create a new LPE model $M'$ that has the same definition as $M$, except that its references to $P$ have been replaced by references to $P'$.

\item Add a new, fresh parameter $f$ of type \texttt{Bool} to $P'$.
Where $M'$ instantiates $P'$, initialize $f$ with $\textbf{false}$.

\item Add a new, fresh parameter $Y$ to $P'$, which is a substitution from variables to values -- in practice, this is implemented with multiple parameters and/or a data hierarchy.
Where $M'$ instantiates $P'$, initialize $Y$ with $[]$.

\item Add to $P'$ each summand $s_i, i \neq \alpha, \beta$ of $P$ after changing the guard of $s_i$ from $g_i$ to $\neg f \land g_i$.

\item Add to $P'$ two new summands ${s_\alpha}'$ and ${s_\beta}'$ that are defined as
\begin{align*}
{s_\alpha}' = C_{\alpha,\beta} \; \texttt{?} \; x_\alpha(1) \; &\cdots{} \; \texttt{?} \; x_\alpha(m_{\alpha,\beta}) \; [[\neg f \land g_\alpha \land \neg g_\beta[X_\alpha]]] \\
&\texttt{>->} \; P(v_\alpha(p_\alpha), \cdots{}, v_\alpha(p_k), \textbf{false}, []) \\
{s_\beta}' = C_{\alpha,\beta} \; \texttt{?} \; x_\beta(1) \; &\cdots{} \; \texttt{?} \; x_\beta(m_{\alpha,\beta}) \; [[\neg f \land \neg g_\alpha[X_\beta] \land g_\beta]] \\
&\texttt{>->} \; P(v_\beta(p_\alpha), \cdots{}, v_\beta(p_k), \textbf{false}, [])
\end{align*}

\item Add to $P'$ a new summand ${s_\gamma}'$ that is defined as
\begin{align*}
{s_\gamma}' &= C_{\alpha,\beta} \; \texttt{?} \; x_\alpha(1) \; \cdots{} \; \texttt{?} \; x_\alpha(m_{\alpha,\beta}) \; [[\neg f \land g_\alpha \land g_\beta[X_\alpha]]] \\
&\texttt{>->} \; P(p_1, \cdots{}, p_k, \textbf{true}, [y(1) \rightarrow x_\alpha(1), \cdots{}, y(m_{\alpha,\beta}) \rightarrow x_\alpha(m_{\alpha,\beta})])
\end{align*}

\item For $i \in \{\alpha, \beta\}$ and for each possible successor $s_\epsilon$ of $s_i$ (see \ref{possiblesuccessors}), add to $P'$ a new summand ${s_\epsilon}'$ that is defined as
\begin{align*}
{s_\epsilon}' = C_\epsilon \; \texttt{?} \; x_\epsilon(1) \; &\cdots{} \; \texttt{?} \; x_\epsilon(m_\epsilon) \; [[f \land g_\epsilon[Y_i]]] \\
&\texttt{>->} \; P(v_\epsilon(p_1)[Y_i], \cdots{}, v_\epsilon(p_k)[Y_i], \textbf{false}, [])
\end{align*}

where
\begin{align*}
Y_i &= [ p_j \rightarrow v_i(p_j)[\overline{Y_i}][Y] \;|\; 1 \leq j \leq k ] \\
\overline{Y_i} &= [x_i(1) \rightarrow y(1), \cdots{}, x_i(m_{\alpha,\beta}) \rightarrow y(m_{\alpha,\beta})]
\end{align*}

\end{enumerate}

Intuitively, the specific non-deterministic behavior of summands $s_\alpha$ and $s_\beta$ is preserved by summand ${s_\gamma}'$, while summands ${s_\alpha}'$ and ${s_\beta}'$ cover the deterministic behavior.
The $f$ parameter indicates that the process has just taken the non-deterministic action of ${s_\gamma}'$, and the $Y$ parameter contains the exact communication values of that action.

If $f$ is \textbf{false}, $P'$ has the same behavior as $P$ because the summands that are created in steps 4 to 6.
If $f$ is \textbf{true}, $P'$ also has the same behavior as $P$, but in such a way that the changes of summands $s_\alpha$ and $s_\beta$ are applied retroactively.

\section{Example}

Consider the following LPE:

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x, y :: Int)
  = A ? i [[x==0]] >-> example[A, B](1, i)
  + A ? i [[x==1 && i==y]] >-> example[A, B](2, y)
  + B [[x==2]] >-> example[A, B](3, y)
  + B [[x==3]] >-> example[A, B](0, y)
  ;

//Initialization:
example[A, B](0, 0);
\end{lstlisting}

TODO

