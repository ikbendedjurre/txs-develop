\chapter{clean} \label{clean}

\section{Introduction}

An LPE may contain redundant information, for example because some of its summands contain all behavior of other summands or because some of its summands will never be (or become) enabled.
Obviously, such summands can be removed without hesitation, which may result in a speedup in other computations in which the LPE is input.

The \texttt{clean} command attempts to detect redundant summands and removes the ones that it finds.
The state space of the LPE is not affected by the changes.

\section{Formal background}

\subsection{Summand containment}

Consider two summands, $s_\alpha$ and $s_\beta$, and reference their elements conform \ref{summandelements}.

Summand $s_\alpha$ is said to \emph{contain} $s_\beta$ if these two conditions hold:

\begin{itemize}
\item $s_\alpha$ and $s_\beta$ must communicate over the exact same channel with exactly as many channel variables; that is, $C_\alpha = C_\beta \land m_\alpha = m_\beta$.

\item Given the previous condition, define $m = m_\alpha = m_\beta$ and, in particular, the mapping
\begin{align*}
X_\alpha = [x_\beta(j) \rightarrow x_\alpha(j) \;|\; 1 \leq j \leq m]
\end{align*}

The following conditions must also hold:
\begin{align*}
g_\beta[X_\alpha] &\rightarrow g_\alpha \\
v_\alpha(p) = v_\beta(p)[X_\alpha] &\leftrightarrow \text{\textit{True}} \text{ for all } p \in [p_1, \cdots{}, p_k]
\end{align*}

The first condition demands that whenever $s_\beta$ is enabled, $s_\alpha$ must also be enabled; consequently, $s_\alpha$ is `always ready' to perform the same behavior as $s_\beta$.
The second condition demands that the state after the application of $s_\alpha$ is the same as the state after the application of $s_\beta$, regardless of the values of communication variables and LPE parameters.
\end{itemize}

Note that $s_\alpha$ could contain all behavior of $s_\beta$ without these two conditions being true (we under-approximate by tolerating false negatives)!

\subsection{Summand reachability}

Consider all possible pairs of summands of the LPE (including symmetric pairs).
Of a given summand pair $(s, t)$, let $s$ be a \emph{possible predecessor} of $s$ if the following expression is satisfiable:
\begin{align*}
g_s \land {g_t}[p \rightarrow v_s(p) \;|\; p \in P]
\end{align*}

where

\begin{itemize}
\item $g_s$ and $g_t$ are the guards of summands $s$ and $t$, respectively;
\item $P$ is the set of all LPE parameters;
\item $v_s(p)$ is the expression that defines the new value of LPE parameter $p$ after the application of summand $s$.
\end{itemize}

A summand $t$ is said to be \emph{reachable} if at least one of these two condition holds:

\begin{itemize}
\item Summand $t$ is enabled in the initial state of the LPE.
Formally, if the LPE is initialized as
\begin{align*}
P(v_I(p_1), \cdots{}, v_I(p_m))
\end{align*}

where

\begin{itemize}
\item $P$ is the LPE to which summand $t$ belongs;
\item $p_1, \cdots{}, p_m$ are the parameters of the LPE, of which there are $m \geq 0$;
\item $v_I(p)$ is a closed expression that defines the initial value of LPE parameter $p$;
\end{itemize}

then
\begin{align*}
g_t[p \rightarrow v_I(p) \;|\; p \in P]
\end{align*}

must be satisfiable.

\item There exists at least one other summand $s$ in the same LPE that is a possible predecessor of $t$.
It is \emph{not} sufficient if the only possible predecessor of $t$ is $t$ itself!
\end{itemize}

\section{Implementation}

\subsection{Algorithm}

The algorithm consists of 2 phases.

In the first phase, the algorithm does a pairwise comparison of all summands of the LPE.
If it discovers that some summand $s_1$ contains another summand $s_2$, it removes $s_2$ from the LPE.

In the second phase, the algorithm starts by determining which summands are reachable in the initial state of the LPE (the first condition for reachability in the previous section).
This becomes the initial value of the set $X$.
Then, until a fixpoint is reached, to $X$ all summands are added of which there exists a possible predecessor in $X$.
The output LPE of the algorithm contains all summands that are in the fixpoint of $X$.

\subsection{Complexity}

The complexity of the algorithm is $O(n^2)$, where $n$ is the number of summands of the input LPE.

\section{Example}

Consider the following LPE:

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int](x :: Int)
  = A ? i [[x==0]] >-> example[A](1)
  + A ? j [[x==1]] >-> example[A](2)
  + A ? k [[x==1]] >-> example[A](2)
  + A ? l [[x==2]] >-> example[A](0)
  + A ? m [[x>=2]] >-> example[A](0)
  ;

//Initialization:
example[A](0);
\end{lstlisting}

The \texttt{clean} command will detect that the second and third summands of the LPE are equivalent and remove one of them.
It will also detect that the fifth summand contains the fourth summand, and therefore remove the fourth summand.

Now consider

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int, B](x :: Int)
  = A ? i [[i != 13]] >-> example[A, B](i)
  + B [[x == 13]] >-> example[A, B](x)
  ;

//Initialization:
example[A, B](0);
\end{lstlisting}

The second summand is unreachable: it is not enabled in the initial state (since \texttt{x = 0}) and it is never enabled after the application of the first summand (since \texttt{i != 13}).

