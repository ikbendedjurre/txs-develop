\chapter{confcheck} \label{confcheck}

\section{Introduction}

The \texttt{confcheck} command perform a \emph{confluence analysis} on the LPE in order to determine which \istep{} summands are \emph{confluent}
A confluent \istep{} summand is an \istep{} summand with the property that the possible behavior of a system is the same up to branching bisimulation before and after the application of that summand.

The \texttt{confcheck} command will rename confluent \istep{}s to \cistep{}s.
The \texttt{confelm} command can be used next in order to prioritize \cistep{}s, which may reduce the state space.

\section{Algorithm}

Consider all possible pairs of summands $(s_1, s_2)$ of the LPE where $s_1$ is a summand that does not communicate over any channel or communicates over the channel \istep{} (these two situations are equivalent).
Then
\begin{align*}
s_i = C_i \; \texttt{?} \; x_i(1) \; \cdots{} \; \texttt{?} \; x_i(m_i) \; [[g_i]] \; \texttt{>->} \; P(v_i(p_1), \cdots{}, v_i(p_k))
\end{align*}

where

\begin{itemize}
\item $C_1$ equals $\istep{}$;
\item $C_2$ is the name of the channel over which summand $s_2$ communicates;
\item $m_i \geq 0$ is the number of variables that summand $s_i$ uses to communicate over channel $C_i$;
\item $x_i(j)$ is the variable that summand $s_i$ uses to communicate the $j$th value of channel $C_i$;
\item $g_i$ is the guard of summand $s_i$ (the only free variables in this expression must be LPE parameters or communication variables of summand $s_i$);
\item $P$ is the LPE to which summand $s_i$ belongs;
\item $p_1, \cdots{}, p_k$ are the parameters of the LPE, of which there are $k \geq 0$;
\item $v_i(p)$ is an expression that defines the new value of LPE parameter $p$ after the application of summand $s_i$ (the only free variables in this expression must be LPE parameters or communication variables of summand $s_i$).
\end{itemize}

Since it cannot be assumed that
\begin{align*}
\{ x_1(1), \cdots{} x_1(m_1) \} \cap \{ x_2(1), \cdots{} x_2(m_2) \} = \emptyset{}
\end{align*}

a substitution $X$ is introduced such that
\begin{align*}
X = [ x_2(j) \rightarrow q(x_2(j)) \;|\; 1 \leq j \leq m_2 ]
\end{align*}

where $q(x)$ is a surjective function that yields fresh variables.

We also define
\begin{align*}
V_{1} &= [p_j \rightarrow v_1(p_j) \;|\; 1 \leq j \leq k] \\
V_{2} &= [p_j \rightarrow v_2(p_j)[X] \;|\; 1 \leq j \leq k]
\end{align*}

Using the definitions above, a particular \istep{} summand $s_1$ is confluent if the following expression is a tautology for all pairs $(s_1, s_2)$ such that $s_2 \neq s_1$:
\begin{align*}
g_1 \land g_2[X] \rightarrow g_1[V_2] \land g_2[X][V_1] \land \bigwedge\limits_{j=1}^{k} p_j[V_2][V_1] = p_j[V_1][V_2]
\end{align*}

Note that this approach does \emph{not} yield all confluent \istep{} summands (it is an under-approximation).

\section{Example TOCHECK}

Consider the following example:

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int](x, y :: Int)
  = A ? i [[x<=9 && x==i]] >-> example[A](x+1, y)
  + ISTEP [[y<=9]] >-> example[A](x, y+1)
  ;

//Initialization:
example[A](0, 0);
\end{lstlisting}

Is the second summand confluent?

If $c_s \land c_t$ holds, then $c_s[\rho_t] \land c_t[\rho_s]$ holds as well.
Since $h_i$ does not use $y$, it is unaffected by $\rho_s$.
Finally,
\begin{align*}
x[\rho_s][\rho_t] = x[\rho_t][\rho_s] = x+1 \\
y[\rho_s][\rho_t] = y[\rho_t][\rho_s] = y+1
\end{align*}

and therefore the confluence condition holds.

So yes, the second summand is confluent.

To store the new information about the second summand, the channel is renamed to CISTEP:

\begin{lstlisting}
//Process definition:
PROCDEF example[A :: Int](x, y :: Int)
  = A ? i [[x<=9 && x==i]] >-> example[A](x+1, y)
  + CISTEP [[y<=9]] >-> example[A](x, y+1)
  ;

//Initialization:
example[A](0, 0);
\end{lstlisting}

